def andrea10():
  set_tcp(p[0.0,0.0,0.178,0.0,0.0,0.5236])
  set_payload(2.6)
  set_tool_voltage(0)
  set_safety_mode_transition_hardness(1)
  set_gravity([8.503688472232543E-16, 6.943788591251896, 6.943788591251898])
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 0)
  set_tool_analog_input_domain(1, 0)
  set_analog_outputdomain(0, 0)
  set_analog_outputdomain(1, 0)
  set_input_actions_to_default()
  step_count_0d6ef7f9_41dc_4baf_9794_ed530f89549f = 0.0
  thread Step_Counter_Thread_6e4b83a3_567a_474a_b048_1b208757b7d5():
    while (True):
      step_count_0d6ef7f9_41dc_4baf_9794_ed530f89549f = step_count_0d6ef7f9_41dc_4baf_9794_ed530f89549f + 1.0
      sync()
    end
  end
  run Step_Counter_Thread_6e4b83a3_567a_474a_b048_1b208757b7d5()
  global Piano_Carrello=p[0.15738038194676504,0.34804679499613556,-0.10180660081110104,-0.604770547029434,0.6135130099633843,1.4699264996051509]
  global Piano_Inclinato=p[0.24163290852284977,0.484348843812812,-0.08183038406600258,-0.13450397856501406,0.1337107555826035,1.5511152546959441]
  global piano_moduli=p[0.13993944179688836,0.3246186948043025,-0.2543011639693953,-0.6047704836459776,0.6135130132010319,1.4699264397811034]
  global XY=[0,0]
  global ant=3
  global col=4
  global ghr=2
  global nCycle=0
  global nfc=1
  global pallStocks=[16,16,16,40,16,16,16,40,16,16,16,40,16,40,0,0]
  global pick=[0,0]
  while (True):
    $ 2 "Robot Program"
    $ 3 "Script: relPose.script"
    def relPose(FeaturePose,vect):
    
        # FeaturePose is the pose for the feature
        # vect = p[0.1, 0, 0, 0, 0, 0] makes us move 10cm in the X direction of the feature
        # credits: https://forum.universal-robots.com/t/move-tcp-relative-to-feature/15492
    
       PoseRelativeToFeature = pose_trans(pose_inv(FeaturePose), get_actual_tcp_pose())
       MoveTCPRelativeToFeature = pose_add(PoseRelativeToFeature, vect)
       return pose_trans(FeaturePose, MoveTCPRelativeToFeature)
    
    end
    $ 4 "Script: tcpMov.script"
    def tcpMov(vect):
    
        # FeaturePose is the pose for the feature
        # vect = p[0.1, 0, 0, 0, 0, 0] makes us move 10cm in the X direction of the feature
        # credits: https://forum.universal-robots.com/t/move-tcp-relative-to-feature/15492
    
       tcp_pose = get_actual_tcp_pose()
       return pose_add(tcp_pose, vect)
    
    
    end
    $ 5 "Script: calcItemPosition.script"
    def calcItemPosition(pick, item, pallDefs, grid, featOrigin):
    
        # calcola la posizione assoluta del pezzo scelto da pickPalletItem
    
        # nPosX è il numero di colonne
        # nPosY è il numero di righe
        # distX è la distanza tra colonne
        # distY è la distanza tra righe
        # [posX1, posY1] è la posizione del primo pezzo rispetto all'origine del pallet
    
        nPallet = pick[0] + 1 # numero del pallet (gli id partono da 0)
        nItem = pick[1] + 1 # numero del pezzo
    
        nPosXgrid = grid[0] # numero di posizioni della giglia in X
        distXgrid = grid[2] # distanza tra gli slot della griglia in X
        distYgrid = grid[3] # distanza tra gli slot della griglia in Y
    
        pallPosX = nPallet%nPosXgrid
        if(pallPosX==0): pallPosX = nPosXgrid end
        pallPosY = ceil(nPallet/nPosXgrid)
    
        pallPosX1 = grid[4]
        pallPosY1 = grid[5]
    
    
        nPosX = pallDefs[item,0]
        nPosY = pallDefs[item,1]
        distX = pallDefs[item,2]
        distY = pallDefs[item,3]
        posX1 = pallDefs[item,4]
        posY1 = pallDefs[item,5]
    
        posX = nItem%nPosX
        if(posX==0): posX = nPosX end
        posY = ceil(nItem/nPosX)
    
        # [X,Y] è la posizione del pezzo rispetto all'origine della griglia
    
        X=distX*(posX - 1) + posX1 + distXgrid*(pallPosX - 1) + pallPosX1
        Y=distY*(posY - 1) + posY1 + distYgrid*(pallPosY - 1) + pallPosY1
        xy=[X,Y]
    
        return xy
    
     end
    $ 6 "Script: pickPalletItem.script"
    def pickPalletItem(type, pallDefs, pallTypes, pallStocks):
    
      # seleziona un pezzo sulla griglia, noti il tipo di pezzo e lo stato della griglia
    
      # lo script funziona finché le variabili del robot non vengono resettate. Tuttavia, anche
      # in caso di riavvio, è possibile scrivere manualmente le info sulla griglia e lo stock
      # all'inizio del programma, così da 'insegnare' al robot dove farlo
      # riprendere
    
      iPallet = 0 # inizializzo l'id del pallet
    
      while iPallet < length(pallStocks):
    
        if pallTypes[iPallet] == type and pallStocks[iPallet] > 0 :
    
          nItems = pallStocks[iPallet] # numero di pezzi nello stock del pallet iesimo
    
          nPosX = pallDefs[type,0] # numero di posizioni lungo x, come definito per il pallet di tipo "type"
          nPosY = pallDefs[type,1] # numero di posizioni lungo y, come definito per il pallet di tipo "type"
    
          stockMax = nPosX*nPosY
          iItem = stockMax - nItems # id del pezzo
    
          pick = [iPallet,iItem]
    
          # pick = [id del pallet, id del pezzo]
    
          return pick
     end
    iPallet = iPallet + 1
    end
    end
    $ 7 "Script: stockUpdate.script"
    def stockUpdate(pick,stock):
    
        # simple function that ingests the output of pickItem and returns the
        # modified stock array. just so to avoid using global variables and
        # multi-dimensional arrays
    
        i = pick[0]
        stock[i] = stock[i] - 1
        return stock
    
    
    end
    $ 8 "Script: ini_grid.script"
    def ini_grid():
    
        # grid = [nPallPosX, nPallPosY, distPallX, distPallY, pallPosX1, pallPosY1, pallPosZ1]
        # la struttura e' del tutto analoga in logica con quella espressa in defs
        grid = [4, 4, 90, 90, 10, 17.5, 6]
        return grid
    end
    $ 9 "Script: ini_defs.script"
    def ini_defs():
    
        # definition = [nPosX,nPosY,distX,distY,posX1,posY1,posZ1]
    
        # nPosX è il numero di colonne
        # nPosY è il numero di righe
        # distX è la distanza tra colonne
        # distY è la distanza tra righe
        # [posX1, posY1] è la posizione del primo pezzo rispetto all'origine del pallet
        # posZ1 e' la posizione che deve raggiungere il TCP lungo asse Z, che sarebbe asse verticale
    
        defs = [
            [0, 0, 0, 0, 0, 0, 0], # slot vuoto
            [4, 10, 18, 8, 11.5, 3.5, 11.1], # pallet nfc
            [4, 4, 21, 21, 5.5, 8.5, 49], # pallet ghiere
            [1, 1, 0, 0, 132.06, 44, 16.05], # stazione antenna
            [1, 2, 0, 40, 20.256, 24, 27.85] # stazione incollaggio
        ]
        return defs
    end
    $ 10 "Script: ini_types.script"
    def ini_types():
    
        visualTypes = [
    
            [0,0,0,0],
            [0,ghr,0,0],
            [0,0,0,nfc],
            [0,ghr,0,0]
    
        ]
    
    # purtroppo fare questa array vuota di dimensione (righe)x(colonne) per aggirare le limitazioni di UR
    # bisogna ricordarsi di cambiare questa dichiarazione di types se si cambia dimensione griglia
    
         types = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    
        iii = 0
        s = size(visualTypes)
        i = 0
        while i < s[0]:
    
            ii=0
            while ii < s[1]:
    
                types[iii] = visualTypes[s[0]-1-i,ii]
                ii = ii + 1
                iii = iii + 1
            end
        i = i + 1
        end
        return types
    end
    $ 11 "Script: ini_stocks2.script"
    def ini_stocks(defs, types):
    
        global f = -1 # usa questo carattere per inizializzare automaticamente pallet pieni
    
        visualStocks = [
    
            [f, f, f, f],
            [f, f, f, f],
            [f, f, f, 36],
            [f ,f, f, f]
    
        ]
    
    # purtroppo fare questa array vuota di dimensione (righe)x(colonne) per aggirare le limitazioni di UR
    # bisogna ricordarsi di cambiare questa dichiarazione di types se si cambia dimensione griglia
    
         stocks = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    
        iii = 0
        s = size(visualStocks)
        i = 0
        while i < s[0]:
    
            ii=0
            while ii < s[1]:
                if visualStocks[s[0]-1-i,ii] == f:
                    nPosX = defs[types[iii], 0]
                    nPosY = defs[types[iii], 1]
                    stocks[iii] = nPosX*nPosY
                else:
    
                    stocks[iii] = visualStocks[s[0]-1-i,ii]
                end
                ii = ii + 1
                iii = iii + 1
            end
        i = i + 1
        end
        return stocks
    end
    $ 12 "If nCycle≟0"
    if (nCycle == 0):
      $ 13 "Set"
      $ 14 "pallTypes≔ini_types()"
      global pallTypes=ini_types()
      $ 15 "grid≔ini_grid()"
      global grid=ini_grid()
      $ 16 "pallDefs≔ini_defs()"
      global pallDefs=ini_defs()
      $ 17 "pallStocks≔ini_stocks(pallDefs,pallTypes)"
      global pallStocks=ini_stocks(pallDefs,pallTypes)
      $ 19 "ghr≔ghr"
      global ghr=ghr
      $ 20 "nfc≔nfc"
      global nfc=nfc
      $ 21 "ant≔ant"
      global ant=ant
      $ 22 "col≔col"
      global col=col
      $ 24 "nCycle≔1"
      global nCycle=1
    end
    $ 26 "MoveJ"
    $ 27 "tcp_pinza" "breakAfter"
    set_tcp(p[0.19312,0.1115,0.045,0.0,0.0,0.0])
    movej(get_inverse_kin(p[.141498008397, .430173161518, -.147714887270, -2.378726041498, .721392256174, 1.710769108532], qnear=[-2.1982067267047327, -0.8817265669452112, 1.812147617340088, -1.9772890249835413, -0.4181411902057093, -0.3771322409259241]), a=1.3962634015954636, v=1.0471975511965976, r=0.025)
    $ 28 "item≔ghr"
    global item=ghr
    $ 29 "pick≔pickPalletItem(item,pallDefs,pallTypes,pallStocks)"
    global pick=pickPalletItem(item,pallDefs,pallTypes,pallStocks)
    $ 30 "lastpick≔pick"
    global lastpick=pick
    $ 32 "XY≔calcItemPosition(pick, item,pallDefs, grid,piano_moduli)"
    global XY=calcItemPosition(pick, item,pallDefs, grid,piano_moduli)
    $ 33 "p_pall≔relPose(piano_moduli_const,p[XY[0]/1000,XY[1]/1000,0.0,0.0,0.0,0.0])"
    global p_pall=relPose(p[0.13993944179688836,0.3246186948043025,-0.2543011639693953,-0.6047704836459776,0.6135130132010319,1.4699264397811034],p[XY[0]/1000,XY[1]/1000,0.0,0.0,0.0,0.0])
    $ 35 "p_pall" "breakAfter"
    set_tcp(p[0.19312,0.1115,0.045,0.0,0.0,0.0])
    movej(p_pall, a=1.3962634015954636, v=1.0471975511965976, r=0.025)
    $ 36 "MoveL"
    $ 37 "p_pezzo≔relPose(piano_moduli,p[0.0, 0.0, -130*0.001, 0.0, 0.0, 0.0])"
    global p_pezzo=relPose(piano_moduli,p[0.0, 0.0, -130*0.001, 0.0, 0.0, 0.0])
    $ 38 "p_pezzo" "breakAfter"
    set_tcp(p[0.19312,0.1115,0.045,0.0,0.0,0.0])
    movel(pose_trans(p[0.0,0.0,0.0,0.0,0.0,0.0], p_pezzo), a=1.2, v=0.25)
    $ 40 "p_pezzo≔relPose(piano_moduli,p[0.0, 0.0, 130/1000, 0.0, 0.0, 0.0])"
    global p_pezzo=relPose(piano_moduli,p[0.0, 0.0, 130/1000, 0.0, 0.0, 0.0])
    $ 41 "p_pezzo" "breakAfter"
    set_tcp(p[0.19312,0.1115,0.045,0.0,0.0,0.0])
    movel(pose_trans(p[0.0,0.0,0.0,0.0,0.0,0.0], p_pezzo), a=1.2, v=0.25)
    $ 42 "pallStocks≔stockUpdate(pick,pallStocks)"
    global pallStocks=stockUpdate(pick,pallStocks)
    $ 44 "MoveJ"
    $ 45 "tcp_ventosaX" "breakAfter"
    set_tcp(p[-0.0475,0.08227,0.045,0.0,0.0,0.0])
    movej(get_inverse_kin(p[.141953232588, .465355611832, -.112212934928, -2.288575391136, -.604632993335, -.263002031189], qnear=[-2.122474306450105, -0.8636770258107109, 1.7563285949973704, -0.037003111853910475, 1.2004593986143597, 2.219123730014088]), a=1.3962634015954636, v=1.0471975511965976, r=0.025)
    $ 47 "item≔nfc"
    global item=nfc
    $ 48 "pick≔pickPalletItem(item,pallDefs,pallTypes,pallStocks)"
    global pick=pickPalletItem(item,pallDefs,pallTypes,pallStocks)
    $ 50 "XY≔calcItemPosition(pick, item,pallDefs, grid,piano_moduli)"
    global XY=calcItemPosition(pick, item,pallDefs, grid,piano_moduli)
    $ 51 "p_pall≔relPose(piano_moduli_const,p[XY[0]/1000,XY[1]/1000,0.0,0.0,0.0,0.0])"
    global p_pall=relPose(p[0.13993944179688836,0.3246186948043025,-0.2543011639693953,-0.6047704836459776,0.6135130132010319,1.4699264397811034],p[XY[0]/1000,XY[1]/1000,0.0,0.0,0.0,0.0])
    $ 53 "p_pall" "breakAfter"
    set_tcp(p[-0.0475,0.08227,0.045,0.0,0.0,0.0])
    movej(p_pall, a=1.3962634015954636, v=1.0471975511965976, r=0.025)
    $ 54 "MoveL"
    $ 55 "p_pezzo≔relPose(piano_moduli,p[0.0, 0.0, -181.4*0.001, 0.0, 0.0, 0.0])"
    global p_pezzo=relPose(piano_moduli,p[0.0, 0.0, -181.4*0.001, 0.0, 0.0, 0.0])
    $ 56 "p_pezzo" "breakAfter"
    set_tcp(p[-0.0475,0.08227,0.045,0.0,0.0,0.0])
    movel(pose_trans(p[0.0,0.0,0.0,0.0,0.0,0.0], p_pezzo), a=1.2, v=0.25)
    $ 57 "Wait: 2.0"
    sleep(2.0)
    $ 58 "p_pezzo≔relPose(piano_moduli,p[0.0, 0.0, 181.4/1000, 0.0, 0.0, 0.0])"
    global p_pezzo=relPose(piano_moduli,p[0.0, 0.0, 181.4/1000, 0.0, 0.0, 0.0])
    $ 59 "p_pezzo" "breakAfter"
    set_tcp(p[-0.0475,0.08227,0.045,0.0,0.0,0.0])
    movel(pose_trans(p[0.0,0.0,0.0,0.0,0.0,0.0], p_pezzo), a=1.2, v=0.25)
    $ 60 "pallStocks≔stockUpdate(pick,pallStocks)"
    global pallStocks=stockUpdate(pick,pallStocks)
    $ 62 "MoveJ"
    $ 63 "Punto_percors_1" "breakAfter"
    set_tcp(p[-0.0475,0.08227,0.045,0.0,0.0,0.0])
    movej(get_inverse_kin(p[.358690535182, .576543462569, -.180700923039, -2.288687233917, -.604526785333, -.262842666819], qnear=[-2.3156607786761683, -0.3765624205218714, 0.9483218193054199, 0.35408663749694824, 1.0783135890960693, 2.052478790283203]), a=1.3962634015954636, v=1.0471975511965976, r=0.025)
    $ 64 "Punto_percors_9" "breakAfter"
    set_tcp(p[-0.0475,0.08227,0.045,0.0,0.0,0.0])
    movej(get_inverse_kin(p[.372703249252, .638173072200, -.276765089068, -2.278072198383, -.699526862292, -.174146469291], qnear=[-2.274402443562643, 0.07982206344604492, 0.23764324188232422, 0.6715139150619507, 1.0422459840774536, 2.0066330432891846]), a=1.3962634015954636, v=1.0471975511965976, r=0.025)
    $ 65 "MoveL"
    $ 66 "p_pezzo≔relPose(piano_moduli,p[0.0, 0.0, -55*0.001, 0.0, 0.0, 0.0])"
    global p_pezzo=relPose(piano_moduli,p[0.0, 0.0, -55*0.001, 0.0, 0.0, 0.0])
    $ 67 "p_pezzo" "breakAfter"
    set_tcp(p[-0.0475,0.08227,0.045,0.0,0.0,0.0])
    movel(pose_trans(p[0.0,0.0,0.0,0.0,0.0,0.0], p_pezzo), a=1.2, v=0.25)
    $ 68 "Wait: 2.0"
    sleep(2.0)
    $ 69 "p_pezzo≔relPose(piano_moduli,p[0.0, 0.0, 55/1000, 0.0, 0.0, 0.0])"
    global p_pezzo=relPose(piano_moduli,p[0.0, 0.0, 55/1000, 0.0, 0.0, 0.0])
    $ 70 "p_pezzo" "breakAfter"
    set_tcp(p[-0.0475,0.08227,0.045,0.0,0.0,0.0])
    movel(pose_trans(p[0.0,0.0,0.0,0.0,0.0,0.0], p_pezzo), a=1.2, v=0.25)
    $ 71 "MoveJ"
    $ 72 "tcp_pinza_s" "breakAfter"
    set_tcp(p[0.19312,0.1115,0.045,0.0,0.0,0.0])
    movej(get_inverse_kin(p[.356783332040, .439978987754, -.038856541448, 1.937935895990, -1.164346024088, -1.082346303919], qnear=[-2.3074405829059046, -0.35617143312563115, 0.798210620880127, -1.0588849226581019, -0.9421032110797327, 0.017457645386457443]), a=1.3962634015954636, v=1.0471975511965976, r=0.025)
    $ 73 "Punto_percors_6" "breakAfter"
    set_tcp(p[0.19312,0.1115,0.045,0.0,0.0,0.0])
    movej(get_inverse_kin(p[.344954736656, .369152169529, -.116441125232, 1.923478756330, -1.218647178234, -1.104476780527], qnear=[-2.3751428763019007, -0.38681155840028936, 1.0999727249145508, -1.3280838171588343, -0.9592068831073206, 0.006781947799026966]), a=1.3962634015954636, v=1.0471975511965976)
    $ 75 "tcp_pinza_s" "breakAfter"
    set_tcp(p[0.19312,0.1115,0.045,0.0,0.0,0.0])
    movej(get_inverse_kin(p[.356783332040, .439978987754, -.038856541448, 1.937935895990, -1.164346024088, -1.082346303919], qnear=[-2.3074405829059046, -0.35617143312563115, 0.798210620880127, -1.0588849226581019, -0.9421032110797327, 0.017457645386457443]), a=1.3962634015954636, v=1.0471975511965976)
    $ 76 "MoveJ"
    $ 77 "tcp_coll_s" "breakAfter"
    set_tcp(p[0.0,0.0,0.178,0.0,0.0,0.5236])
    movej(get_inverse_kin(p[.355979551223, .389943966877, -.058821279618, -.022136014641, -3.113784733110, .402485864078], qnear=[-2.428810183201925, -1.122378174458639, 1.855982780456543, -2.129040066395895, -1.759765926991598, 1.7969952821731567]), a=1.3962634015954636, v=1.0471975511965976)
    $ 78 "Punto_percors_7" "breakAfter"
    set_tcp(p[0.0,0.0,0.178,0.0,0.0,0.5236])
    movej(get_inverse_kin(p[.346196209070, .368904131368, -.136541611951, -.022031189392, -3.113760537315, .402467171482], qnear=[-2.441366736088888, -1.0385530630694788, 1.951913833618164, -2.3111045996295374, -1.7625578085528772, 1.7847346067428589]), a=1.3962634015954636, v=1.0471975511965976)
    $ 79 "Punto_percors_8" "breakAfter"
    set_tcp(p[0.0,0.0,0.178,0.0,0.0,0.5236])
    movej(get_inverse_kin(p[.346193429388, .368066583704, -.139506793277, -.022227884690, -3.113704745611, .402651224222], qnear=[-2.4425047079669397, -1.0335286299334925, 1.9548468589782715, -2.319160286580221, -1.762845818196432, 1.7837516069412231]), a=1.3962634015954636, v=1.0471975511965976)
    $ 80 "Punto_percors_7" "breakAfter"
    set_tcp(p[0.0,0.0,0.178,0.0,0.0,0.5236])
    movej(get_inverse_kin(p[.346196209070, .368904131368, -.136541611951, -.022031189392, -3.113760537315, .402467171482], qnear=[-2.441366736088888, -1.0385530630694788, 1.951913833618164, -2.3111045996295374, -1.7625578085528772, 1.7847346067428589]), a=1.3962634015954636, v=1.0471975511965976)
    $ 82 "arco01" "breakAfter"
    set_tcp(p[0.0,0.0,0.178,0.0,0.0,0.5236])
    movej(get_inverse_kin(p[.335049938345, .375394498852, -.109368767847, -.242659546875, 2.873056834243, -.373533979509], qnear=[-2.340151850377218, -1.090508762990133, 2.097583532333374, -2.5866525808917444, -1.9184592405902308, 1.6785742044448853]), a=1.3962634015954636, v=1.0471975511965976)
    $ 83 "MoveP"
    $ 84 "CircleMove"
    $ 85 "ViaPoint_1" "noBreak"
    set_tcp(p[0.0,0.0,0.178,0.0,0.0,0.5236])
    $ 86 "EndPoint_1" "breakAfter"
    set_tcp(p[0.0,0.0,0.178,0.0,0.0,0.5236])
    movec(p[.344502893442, .376803289707, -.105537295174, -.089347178614, -3.055795403483, .394384116458], p[.354817650821, .374158419673, -.109195496531, -.426611404530, -2.702522389619, .345880457655], a=0.02, v=0.005, r=0.001, mode=1)
    $ 87 "Wait: 0.5"
    sleep(0.5)
    $ 88 "MoveP"
    $ 89 "EndPoint_1" "breakAfter"
    set_tcp(p[0.0,0.0,0.178,0.0,0.0,0.5236])
    movep(p[.354817650821, .374158419673, -.109195496531, -.426611404530, -2.702522389619, .345880457655], a=0.02, v=0.005, r=0.001)
    $ 90 "CircleMove"
    $ 91 "ViaPoint_1" "noBreak"
    set_tcp(p[0.0,0.0,0.178,0.0,0.0,0.5236])
    $ 92 "arco01" "breakAfter"
    set_tcp(p[0.0,0.0,0.178,0.0,0.0,0.5236])
    movec(p[.344502893442, .376803289707, -.105537295174, -.089347178614, -3.055795403483, .394384116458], p[.335049938345, .375394498852, -.109368767847, -.242659546875, 2.873056834243, -.373533979509], a=0.02, v=0.005, r=0.0, mode=1)
    $ 93 "MoveJ"
    $ 94 "tcp_coll_s" "breakAfter"
    set_tcp(p[-0.0475,0.08227,0.045,0.0,0.0,0.0])
    movej(get_inverse_kin(p[.355979551223, .389943966877, -.058821279618, -.022136014641, -3.113784733110, .402485864078], qnear=[-2.428810183201925, -1.122378174458639, 1.855982780456543, -2.129040066395895, -1.759765926991598, 1.7969952821731567]), a=1.3962634015954636, v=1.0471975511965976, r=0.025)
    $ 95 "Punto_percors_5" "breakAfter"
    set_tcp(p[-0.0475,0.08227,0.045,0.0,0.0,0.0])
    movej(get_inverse_kin(p[.349318901653, .341119634234, -.008563537337, -1.018468555377, -1.314638151411, 1.000068392579], qnear=[-2.677573029194967, -0.8645547072040003, 1.5062251091003418, -0.6398785750018519, -1.087501351033346, 2.87459135055542]), a=1.3962634015954636, v=1.0471975511965976)
    $ 96 "Punto_percor_11" "breakAfter"
    set_tcp(p[-0.0475,0.08227,0.045,0.0,0.0,0.0])
    movej(get_inverse_kin(p[.349675365215, .371111549455, -.122130282842, -1.018531879067, -1.314504385094, 1.000199281638], qnear=[-2.6338749567614954, -0.6525400320636194, 1.458961009979248, -0.8050702253924769, -1.043718163167135, 2.875790596008301]), a=1.3962634015954636, v=1.0471975511965976)
    $ 97 "Wait: 1.0"
    sleep(1.0)
    $ 98 "Punto_percors_5" "breakAfter"
    set_tcp(p[-0.0475,0.08227,0.045,0.0,0.0,0.0])
    movej(get_inverse_kin(p[.349318901653, .341119634234, -.008563537337, -1.018468555377, -1.314638151411, 1.000068392579], qnear=[-2.677573029194967, -0.8645547072040003, 1.5062251091003418, -0.6398785750018519, -1.087501351033346, 2.87459135055542]), a=1.3962634015954636, v=1.0471975511965976)
    $ 101 "MoveL"
    $ 102 "Punto_percor_12" "breakAfter"
    set_tcp(p[-0.14289,-0.0825,0.045,0.0,0.0,0.0])
    movel(p[.349833769396, .374866832175, -.104947483943, .198176160502, -1.562479833491, -.220379446853], a=1.2, v=0.25, r=0.025)
    $ 103 "Punto_percor_13" "breakAfter"
    set_tcp(p[-0.14289,-0.0825,0.045,0.0,0.0,0.0])
    movel(p[.348512119133, .367849553856, -.131981935191, .198229659423, -1.562679692958, -.220537427727], a=1.2, v=0.25)
    $ 104 "Wait: 2.0"
    sleep(2.0)
    $ 105 "Punto_percor_12" "breakAfter"
    set_tcp(p[-0.14289,-0.0825,0.045,0.0,0.0,0.0])
    movel(p[.349833769396, .374866832175, -.104947483943, .198176160502, -1.562479833491, -.220379446853], a=1.2, v=0.25)
    $ 108 "MoveJ"
    $ 109 "tcp_pinza_s" "breakAfter"
    set_tcp(p[0.19312,0.1115,0.045,0.0,0.0,0.0])
    movej(get_inverse_kin(p[.356783332040, .439978987754, -.038856541448, 1.937935895990, -1.164346024088, -1.082346303919], qnear=[-2.3074405829059046, -0.35617143312563115, 0.798210620880127, -1.0588849226581019, -0.9421032110797327, 0.017457645386457443]), a=1.3962634015954636, v=1.0471975511965976, r=0.025)
    $ 110 "Punto_percors_6" "breakAfter"
    set_tcp(p[0.19312,0.1115,0.045,0.0,0.0,0.0])
    movej(get_inverse_kin(p[.344954736656, .369152169529, -.116441125232, 1.923478756330, -1.218647178234, -1.104476780527], qnear=[-2.3751428763019007, -0.38681155840028936, 1.0999727249145508, -1.3280838171588343, -0.9592068831073206, 0.006781947799026966]), a=1.3962634015954636, v=1.0471975511965976)
    $ 112 "tcp_pinza_s" "breakAfter"
    set_tcp(p[0.19312,0.1115,0.045,0.0,0.0,0.0])
    movej(get_inverse_kin(p[.356783332040, .439978987754, -.038856541448, 1.937935895990, -1.164346024088, -1.082346303919], qnear=[-2.3074405829059046, -0.35617143312563115, 0.798210620880127, -1.0588849226581019, -0.9421032110797327, 0.017457645386457443]), a=1.3962634015954636, v=1.0471975511965976, r=0.025)
    $ 113 "MoveJ"
    $ 114 "tcp_pinza" "breakAfter"
    set_tcp(p[0.19312,0.1115,0.045,0.0,0.0,0.0])
    movej(get_inverse_kin(p[.141498008397, .430173161518, -.147714887270, -2.378726041498, .721392256174, 1.710769108532], qnear=[-2.1982067267047327, -0.8817265669452112, 1.812147617340088, -1.9772890249835413, -0.4181411902057093, -0.3771322409259241]), a=1.3962634015954636, v=1.0471975511965976, r=0.025)
    $ 116 "XY≔calcItemPosition(lastpick, item,pallDefs, grid,piano_moduli)"
    global XY=calcItemPosition(lastpick, item,pallDefs, grid,piano_moduli)
    $ 117 "p_pall≔relPose(piano_moduli_const,p[XY[0]/1000,XY[1]/1000,0.0,0.0,0.0,0.0])"
    global p_pall=relPose(p[0.13993944179688836,0.3246186948043025,-0.2543011639693953,-0.6047704836459776,0.6135130132010319,1.4699264397811034],p[XY[0]/1000,XY[1]/1000,0.0,0.0,0.0,0.0])
    $ 119 "p_pall" "breakAfter"
    set_tcp(p[0.19312,0.1115,0.045,0.0,0.0,0.0])
    movej(p_pall, a=1.3962634015954636, v=1.0471975511965976, r=0.025)
    $ 120 "MoveJ"
    $ 121 "p_pezzo≔relPose(piano_moduli,p[0.0, 0.0, -130*0.001, 0.0, 0.0, 0.0])"
    global p_pezzo=relPose(piano_moduli,p[0.0, 0.0, -130*0.001, 0.0, 0.0, 0.0])
    $ 122 "p_pezzo" "breakAfter"
    set_tcp(p[0.19312,0.1115,0.045,0.0,0.0,0.0])
    movej(p_pezzo, a=1.3962634015954636, v=1.0471975511965976)
    $ 124 "p_pezzo≔relPose(piano_moduli,p[0.0, 0.0, 130/1000, 0.0, 0.0, 0.0])"
    global p_pezzo=relPose(piano_moduli,p[0.0, 0.0, 130/1000, 0.0, 0.0, 0.0])
    $ 125 "p_pezzo" "breakAfter"
    set_tcp(p[0.19312,0.1115,0.045,0.0,0.0,0.0])
    movej(p_pezzo, a=1.3962634015954636, v=1.0471975511965976)
  end
end
